/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["SmoothReflow"] = factory();
	else
		root["SmoothReflow"] = factory();
})(typeof self !== 'undefined' ? self : this, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\n/**\n * The general flow is:\n *\n * 1. Save element DOM state in beforeUpdate()\n * 2. Get element DOM state in updated()\n * 3. Animate the diff in doSmoothReflow()\n * 4. Listen for transitionend event in endListener().\n * 5. If the event matches the user's event filters, Go back to #1\n */\n\nvar mixin = {\n  methods: {\n    $smoothReflow: function $smoothReflow(options) {\n      var _registerElement = registerElement.bind(this);\n      if (Array.isArray(options)) options.forEach(_registerElement);else _registerElement(options);\n    },\n    $unsmoothReflow: function $unsmoothReflow(options) {\n      var _unregisterElement = unregisterElement.bind(this);\n      if (Array.isArray(options)) options.forEach(_unregisterElement);else _unregisterElement(options);\n    }\n  },\n  beforeMount: function beforeMount() {\n    var _this = this;\n    this._smoothElements = [];\n    this._endListener = function (event) {\n      var _iterator = _createForOfIteratorHelper(_this._smoothElements),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var smoothEl = _step.value;\n          smoothEl.endListener(event);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    };\n  },\n  mounted: function mounted() {\n    this.$el.addEventListener('transitionend', this._endListener, {\n      passive: true\n    });\n  },\n  unmounted: function unmounted() {\n    this.$el.removeEventListener('transitionend', this._endListener, {\n      passive: true\n    });\n  },\n  beforeUpdate: function beforeUpdate() {\n    // The component $el can be null during mounted, if it's hidden by a falsy v-if\n    // Duplicate event listeners are ignored, so it's safe to add this listener multiple times.\n    this.$el.addEventListener('transitionend', this._endListener, {\n      passive: true\n    });\n    flushRemoved(this);\n    // Retrieve component element on demand\n    // It could have been hidden by v-if/v-show\n    var _iterator2 = _createForOfIteratorHelper(this._smoothElements),\n      _step2;\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var smoothEl = _step2.value;\n        var $smoothEl = findRegisteredEl(this.$el, smoothEl.options.el);\n        smoothEl.setSmoothElement($smoothEl);\n        smoothEl.setBeforeValues();\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  },\n  updated: function updated() {\n    var _this2 = this;\n    this.$nextTick(function () {\n      // Retrieve component element on demand\n      // It could have been hidden by v-if/v-show\n      var _iterator3 = _createForOfIteratorHelper(_this2._smoothElements),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var smoothEl = _step3.value;\n          var $smoothEl = findRegisteredEl(_this2.$el, smoothEl.options.el);\n          smoothEl.setSmoothElement($smoothEl);\n          smoothEl.doSmoothReflow();\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n      flushRemoved(_this2);\n    });\n  }\n};\nfunction flushRemoved(vm) {\n  var i = vm._smoothElements.length;\n  while (i--) {\n    var smoothEl = vm._smoothElements[i];\n    if (smoothEl.isRemoved) {\n      smoothEl.stopTransition();\n      vm._smoothElements.splice(i, 1);\n    }\n  }\n}\n\n// 'this' is vue component\nfunction registerElement() {\n  var option = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  this._smoothElements.push(new SmoothElement(option));\n}\n\n// 'this' is vue component\n// If no 'el' was pass during registration, then we register the root element.\nfunction unregisterElement() {\n  var option = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultOptions();\n  var root = this.$el;\n  var index = this._smoothElements.findIndex(function (smoothEl) {\n    return findRegisteredEl(root, smoothEl.options.el) === findRegisteredEl(root, option.el);\n  });\n  if (index === -1) {\n    console.error(\"VSR_ERROR: $unsmoothReflow failed due to invalid el option\");\n    return;\n  }\n  // Don't remove right away, as it might be in the middle of\n  // a doSmoothReflow, and leave the element in a broken state.\n  this._smoothElements[index].scheduleRemoval();\n}\nfunction findRegisteredEl($root, registeredEl) {\n  // Is an element hidden by v-if\n  if (!$root || $root instanceof Node && $root.nodeType === Node.COMMENT_NODE) {\n    return null;\n  }\n  // Fallback to component root el.\n  if (registeredEl === null) {\n    return $root;\n  }\n  return select($root, registeredEl);\n}\nfunction select($root, el) {\n  if (typeof el === 'string') return $root.matches(el) ? $root : $root.querySelector(el);else return el;\n}\nvar STATES = {\n  INACTIVE: 'INACTIVE',\n  ACTIVE: 'ACTIVE'\n};\nvar defaultOptions = function defaultOptions() {\n  return {\n    // Element or selector string.\n    // If null, VSR will use the component's root el.\n    el: null,\n    // Valid values: height, width, transform\n    property: 'height',\n    // Selector string that will emit a transitionend event.\n    // Note that you can specify multiple transitionend\n    // event emitters through the use of commas.\n    transitionEvent: null,\n    // Hide scrollbar during transition. This should be on 99% of the time.\n    hideOverflow: true,\n    debug: false\n  };\n};\nvar SmoothElement = /*#__PURE__*/function () {\n  function SmoothElement(userOptions) {\n    _classCallCheck(this, SmoothElement);\n    var options = defaultOptions();\n    Object.assign(options, userOptions);\n    var properties = this.parsePropertyOption(options.property);\n    if (!options.transition) {\n      options.transition = properties.map(function (p) {\n        return \"\".concat(p, \" .5s\");\n      }).join(',');\n    }\n    var internal = {\n      // Resolved Element from el\n      $smoothEl: null,\n      // Resolved properties from property\n      properties: properties,\n      beforeRect: {},\n      state: STATES.INACTIVE,\n      isRemoved: false\n    };\n    Object.assign(this, {\n      options: options\n    }, internal);\n    this.endListener = this.endListener.bind(this);\n    this.debug = this.debug.bind(this);\n  }\n  _createClass(SmoothElement, [{\n    key: \"setSmoothElement\",\n    value: function setSmoothElement($smoothEl) {\n      this.$smoothEl = $smoothEl;\n    }\n  }, {\n    key: \"transitionTo\",\n    value: function transitionTo(to) {\n      this.state = to;\n    }\n  }, {\n    key: \"parsePropertyOption\",\n    value: function parsePropertyOption(property) {\n      if (typeof property === 'string') {\n        return [property];\n      } else if (Array.isArray(property)) {\n        return property;\n      }\n      return [];\n    } // Save the DOM properties of the $smoothEl before the data update\n  }, {\n    key: \"setBeforeValues\",\n    value: function setBeforeValues() {\n      var $smoothEl = this.$smoothEl;\n      this.beforeRect = {};\n      if (!$smoothEl) {\n        return;\n      }\n      var computedStyle = window.getComputedStyle($smoothEl);\n      // getComputedStyle() can return null in iframe\n      var _ref = computedStyle || {},\n        transition = _ref.transition,\n        overflowX = _ref.overflowX,\n        overflowY = _ref.overflowY;\n      this.computedTransition = transition;\n      // Save overflow values now\n      this.overflowX = overflowX;\n      this.overflowY = overflowY;\n      this.beforeRect = getBoundingClientRect($smoothEl);\n\n      // Important to stopTransition after we've saved this.beforeRect\n      if (this.state === STATES.ACTIVE) {\n        this.stopTransition();\n        this.debug('Transition was interrupted.');\n      }\n    }\n  }, {\n    key: \"didValuesChange\",\n    value: function didValuesChange(beforeRect, afterRect) {\n      var b = beforeRect;\n      var a = afterRect;\n      // There's nothing to transition from.\n      if (Object.keys(beforeRect).length === 0) {\n        return false;\n      }\n      var _iterator4 = _createForOfIteratorHelper(this.properties),\n        _step4;\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var prop = _step4.value;\n          if (prop === 'transform' && (b['top'] !== a['top'] || b['left'] !== a['left'])) {\n            return true;\n          } else if (b[prop] !== a[prop]) {\n            return true;\n          }\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n      return false;\n    }\n  }, {\n    key: \"doSmoothReflow\",\n    value: function doSmoothReflow() {\n      var event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'data update';\n      var $smoothEl = this.$smoothEl;\n      if (!$smoothEl) {\n        this.debug(\"Could not find registered el to perform doSmoothReflow.\");\n        this.transitionTo(STATES.INACTIVE);\n        return;\n      }\n      // A transition is already occurring, don't interrupt it.\n      if (this.state === STATES.ACTIVE) {\n        return;\n      }\n      // TODO: This listener might be necessary if the smoothEl is not rendered inside the component\n      // for example if smoothEl is inside a <template></template>\n      // https://github.com/guanzo/vue-smooth-reflow/issues/1\n      //$smoothEl.addEventListener('transitionend', this.endListener, { passive: true })\n      var beforeRect = this.beforeRect,\n        properties = this.properties,\n        options = this.options,\n        overflowX = this.overflowX,\n        overflowY = this.overflowY,\n        debug = this.debug;\n      this.transitionTo(STATES.ACTIVE);\n      var triggeredBy = typeof event === 'string' ? event : event.target;\n      debug(\"doSmoothReflow triggered by:\", triggeredBy);\n      var afterRect = getBoundingClientRect($smoothEl);\n      if (!this.didValuesChange(beforeRect, afterRect)) {\n        debug(\"Property values did not change.\");\n        this.transitionTo(STATES.INACTIVE);\n        return;\n      }\n      debug('beforeRect', beforeRect);\n      debug('afterRect', afterRect);\n      this.saveOverflowValues($smoothEl, overflowX, overflowY);\n      var _iterator5 = _createForOfIteratorHelper(properties),\n        _step5;\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var prop = _step5.value;\n          if (prop === 'transform') {\n            var invertLeft = beforeRect['left'] - afterRect['left'];\n            var invertTop = beforeRect['top'] - afterRect['top'];\n            $smoothEl.style.transform = \"translate(\".concat(invertLeft, \"px, \").concat(invertTop, \"px)\");\n          } else {\n            $smoothEl.style[prop] = beforeRect[prop] + 'px';\n          }\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n      $smoothEl.offsetHeight; // Force reflow\n\n      $smoothEl.style.transition = [this.computedTransition, options.transition].filter(function (d) {\n        return d;\n      }).join(',');\n      var _iterator6 = _createForOfIteratorHelper(properties),\n        _step6;\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var _prop = _step6.value;\n          if (_prop === 'transform') {\n            $smoothEl.style.transform = '';\n          } else {\n            $smoothEl.style[_prop] = afterRect[_prop] + 'px';\n          }\n        }\n\n        // Transition is now started.\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n    }\n  }, {\n    key: \"endListener\",\n    value: function endListener(event) {\n      var $smoothEl = this.$smoothEl,\n        properties = this.properties;\n      var $targetEl = event.target;\n      // Transition on smooth element finished\n      if ($smoothEl === $targetEl) {\n        // The transition property is one that was registered\n        if (properties.includes(event.propertyName)) {\n          this.stopTransition();\n          // Record the beforeValues AFTER the data change, but potentially\n          // BEFORE any transitionend events.\n          if (this.hasRegisteredEventEmitter()) {\n            this.setBeforeValues();\n          }\n        }\n      } else if (this.isRegisteredEventEmitter($smoothEl, event)) {\n        this.doSmoothReflow(event);\n      }\n    }\n  }, {\n    key: \"hasRegisteredEventEmitter\",\n    value: function hasRegisteredEventEmitter() {\n      var transitionEvent = this.options.transitionEvent;\n      return transitionEvent !== null && Object.keys(transitionEvent).length > 0;\n    }\n    // Check if we should perform doSmoothReflow() after a transitionend event.\n  }, {\n    key: \"isRegisteredEventEmitter\",\n    value: function isRegisteredEventEmitter($smoothEl, event) {\n      if (!this.hasRegisteredEventEmitter()) {\n        return false;\n      }\n      var $targetEl = event.target;\n      var _this$options$transit = this.options.transitionEvent,\n        selector = _this$options$transit.selector,\n        propertyName = _this$options$transit.propertyName;\n      if (propertyName != null && propertyName !== event.propertyName) {\n        return false;\n      }\n      // '!= null' coerces the type to also check for undefined.\n      if (selector != null && !$targetEl.matches(selector)) {\n        return false;\n      }\n\n      // If 'transform' isn't a registered property,\n      // then we don't need to act on any transitionend\n      // events that occur outside the $smoothEl\n      if (this.properties.indexOf('transform') === -1) {\n        // Checks if $targetEl IS or WAS a descendent of $smoothEl.\n        var smoothElContainsTarget = false;\n        // composedPath is missing in ie/edge of course.\n        var path = event.composedPath ? event.composedPath() : [];\n        var _iterator7 = _createForOfIteratorHelper(path),\n          _step7;\n        try {\n          for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n            var el = _step7.value;\n            if ($smoothEl === el) {\n              smoothElContainsTarget = true;\n              break;\n            }\n          }\n        } catch (err) {\n          _iterator7.e(err);\n        } finally {\n          _iterator7.f();\n        }\n        if (!smoothElContainsTarget) {\n          return false;\n        }\n      }\n      return true;\n    }\n  }, {\n    key: \"saveOverflowValues\",\n    value: function saveOverflowValues($smoothEl, overflowX, overflowY) {\n      if (this.options.hideOverflow) {\n        //save overflow properties before overwriting\n        this.overflowX = overflowX;\n        this.overflowY = overflowY;\n        $smoothEl.style.overflowX = 'hidden';\n        $smoothEl.style.overflowY = 'hidden';\n      }\n    }\n  }, {\n    key: \"restoreOverflowValues\",\n    value: function restoreOverflowValues($smoothEl) {\n      var options = this.options,\n        overflowX = this.overflowX,\n        overflowY = this.overflowY;\n      if (options.hideOverflow) {\n        // Restore original overflow properties\n        $smoothEl.style.overflowX = overflowX;\n        $smoothEl.style.overflowY = overflowY;\n      }\n    }\n  }, {\n    key: \"stopTransition\",\n    value: function stopTransition() {\n      var $smoothEl = this.$smoothEl,\n        properties = this.properties;\n      // Change prop back to auto\n      var _iterator8 = _createForOfIteratorHelper(properties),\n        _step8;\n      try {\n        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n          var prop = _step8.value;\n          $smoothEl.style[prop] = null;\n        }\n      } catch (err) {\n        _iterator8.e(err);\n      } finally {\n        _iterator8.f();\n      }\n      this.restoreOverflowValues($smoothEl);\n      // Clean up inline transition\n      $smoothEl.style.transition = null;\n      this.transitionTo(STATES.INACTIVE);\n    }\n  }, {\n    key: \"scheduleRemoval\",\n    value: function scheduleRemoval() {\n      this.isRemoved = true;\n    }\n  }, {\n    key: \"debug\",\n    value: function debug() {\n      if (!this.options.debug) {\n        return;\n      }\n      var args = [\"VSR_DEBUG:\"].concat(Array.from(arguments));\n      console.log.apply(null, args);\n    }\n  }]);\n  return SmoothElement;\n}(); // Converts DOMRect into plain object.\n// Overflow is temporarily forced to 'hidden' to prevent margin collapse,\n// and receive an accurate height/width value.\nvar getBoundingClientRect = function getBoundingClientRect($el) {\n  $el.style.overflow = 'hidden';\n  var _$el$getBoundingClien = $el.getBoundingClientRect(),\n    top = _$el$getBoundingClien.top,\n    right = _$el$getBoundingClien.right,\n    bottom = _$el$getBoundingClien.bottom,\n    left = _$el$getBoundingClien.left,\n    width = _$el$getBoundingClien.width,\n    height = _$el$getBoundingClien.height,\n    x = _$el$getBoundingClien.x,\n    y = _$el$getBoundingClien.y;\n  $el.style.overflow = null;\n  return {\n    top: top,\n    right: right,\n    bottom: bottom,\n    left: left,\n    width: width,\n    height: height,\n    x: x,\n    y: y\n  };\n};\n\n// Remember: this code shouldn't run during SSR.\n// Element.matches polyfill: https://developer.mozilla.org/en-US/docs/Web/API/Element/matches#Polyfill\nif (typeof Element !== 'undefined' && Element.prototype && !Element.prototype.matches) {\n  Element.prototype.matches = Element.prototype.matchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector || Element.prototype.oMatchesSelector || Element.prototype.webkitMatchesSelector || function (s) {\n    var matches = (this.document || this.ownerDocument).querySelectorAll(s),\n      i = matches.length;\n    while (--i >= 0 && matches.item(i) !== this) {}\n    return i > -1;\n  };\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (mixin);\n\n//# sourceURL=webpack://SmoothReflow/./src/index.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The require scope
/******/ 	var __webpack_require__ = {};
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./src/index.js"](0, __webpack_exports__, __webpack_require__);
/******/ 	__webpack_exports__ = __webpack_exports__["default"];
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});